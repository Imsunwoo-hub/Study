# 자로구조 : 
  - 특정한 목적을 달성하기 위해 자료를 구조화한것
  - 추상적 자료구조 : 데이터 + 연산들의 집합
  - 알고리즘과 밀접한 관계가 있음(자료구조 선택에 따라 적용하는 알고리즘이 달라짐)
  - 시간복잡도 : 문제해결을 위해 얼마 만큼의 연산 시간을 필요로하는가
  - 공간복잡도 : 문제해결을 위해 얼마 만큼의 메모리 공간을 필요로하는가
  
  
  선형배열(array, arraylist) : 
    - 원소들을 순서대로 늘어놓은 구조
    - 연속된 메모리 위치에 저장
    - 인덱스를 적용, 인덱스를 통한 데이터 접근
   
  연결리스트(linkedlist) : 
    - 원소들이 연속된 메모리 위치에 저장되지 않는 선형데이터 구조
    - 동적으로 크기 변경이 가능
    - 데이터 추가, 삭제가 용이
    - 순차적으로 요소에 접근
    - 이진탐색 불가능
    - 포인터를 저장할 별도의 공강 필요
 
 *array : 정적 크기 할당, 인덱스를 통한 데이터 접근, 삽입,삭제의 어려움
 *arraylist : 동적 크기 할당, 인덱스를 통한 데이터 접근, 삽입,삭제의 어려움
 *linkedlist : 동적 크기 할당, 순차적으로 데이터 접근, 삽입, 삭제 용이
 
 배열 탐색 : 
    - 선형 탐색 : 배열의 원소에 아무런 가정도 하지않음
                단방향 탐색
                O(N)
    - 이진 탐색 : 배열의 원소가 정렬되어 있음을 가정
                데이터 크기의 반씩 탐색
                O(logN)
 
 스택 : 
    - 선형구조
    - 데이터를 넣고 꺼내는 방향이 하나
    - 후입선출(마지막으로 들어간 데이터가 먼저 나옴)
    - 스택오버플로우 : 꽉찬 스택에 데이터를 넣으려 할때 발생하는 오류
    - DFS 탐색, 재귀함수, 수식 괄호 유효성 검사 등에서 활용
 
 큐 : 
    - 선형구조
    - 데이터를 넣는 방향과 꺼내는 방향이 별도로 존재
    - 선입선출(먼저 들어간 데이터가 먼저 나옴)
    - BFS 탐색 등에 활용됨
    
데크 :
    - 선형구조
    - 데이터의 삽입,삭제가 양방향에서 이루어짐
    - 선입선출, 후입선출 모두 가능
    - 큐와 스택의 장점을 모두 가지고 있음
   
트리 : 
    - 비선형구조
    - 정점과 간선을 이용하여 데이터 배치를 추상화한 자료구조
    - 노드간 사이클을 허용하지 않음
    - 루트노드 : 부모노드가 없는 노드
    - 리프노드 : 자식노드가 없는 노드
    - 레벨 : 루트로 부터 노드 자신까지의 간선의 수
    - 트리의 높이/깊이 : 트리 노드의 최대 레벨 + 1
    - 노드의 차수 : 자식노드의 개수
    - 트리의 차수 : 노드의 차수 중 최대값
    * 이진트리 : 모든 노드의 차수가 2 이하인 트리
    * 이진탐색트리 : 트리가 이진트리일때 모든 왼쪽 서브트리의 값이 루트노드 보다 작고 오른쪽 서브트리가 루트노드 보다 큰 트리 (중복허용X)
                     데이터 추가, 삭제가 용이하며 공간 소요가 큼, 중위 순외 방식의 탐색
    * 완전이진트리 : 모든 자식노드가 왼쪽부터 채워진 트리
    * 풀이진트리 : 마지막 레벨까지 노드의 차수가 모두 2인 트리
    
힙 :
   - 완전이진트리의 일종으로 우선순위큐에서 위해 활용되는 자료구조
   - 반정렬 상태를 유지
   - 중복값 허용
   * 최대힙 : 부모노드의 값이 자식노드의 값보다 크거나 같은 완전이진트리
   * 최소힙 : 부모노드의 값이 자식노드의 값보다 작거나 같은 완전이진트리

B-트리 : 
    - 데이터베이스, 파일시스템에서 사용되는 트리 자료구조의 일종
    - 이진트리를 확장하여 더 많은 자식노드를 가질 수 있도록 일반화한 것
    - 균등한 응답속도를 유지하기 위해 리프노드의 좌우균형을 유지하는 트리
    - 구조를 유지하기 위해 추가적으로 연산을 해야한다는 것
    - 하나의 노드에 많은 데이터를 가질 수 있음
    - 각 노드의 데이터는 정렬된 상태여야함(중복X)
    - 루트노드는 2개 이상의 자식을 가져야함
    - 노드의 데이터 수가 N이면 자식노드는 N+1 이여야함
    - * M : 한노드에 들어갈 수 있는 최대 데이터의 개수
    - 루트노드를 제외한 모든 노드는 M/2 개 이상의 데이터를 가져야함
    - O(logN)의 검색속도
    * B+ 트리 : B트리의 리프노드간 순차탐색 문제를 해결하기 위해 리프노드간에 링크드리스트 구성
    * B* 트리 : B트리의 구조유지를 위한 추가 연산 문제를 해결하기 위해 2/M의 이상의 키값을 가져야하는 조건을 2/3로 변경
    
트라이 : 
    - 문자열 검색을 빠르게 도와주는 트리 구조
    * M : 문자열 길이
    - 이진탐색트리에서의 문자열 검색 : O(M*logN)
    - 트라이 문자열 검색 : O(M)
    - 저장공간의 크기가 비교적 큼
    - 검색어 자동완성, 사전에서 단어 찾기, 문자열 검사 등에서 활용

해시 테이블 : 
    - 해시 함수를 통해 키를 해시 값으로 매핑하고 해시 값을 인덱스 또는 주소로 활용하여 key, value를 함께 저장하는 자료구조
    - key : 중복와 null 값을 허용하지 않음, 해시함수를 통해 일정 길이의 해시값으로 변경
    - value : 최종적으로 저장되는 값으로 해시값과 매핑되어 저장됨
    - 해시함수 : key를 고정된 길이의 해시로 변헝하는 함수
    - 해시충돌 : 서로 다른 키가 같은 해시 값을 갖는 것
    - 삽입, 삭제, 검색 모두 O(1)의 시간 복잡도를 가짐
    - 순서가 없음
    - 공간 효율성이 떨어짐
    - JDK 1.0 부터 존재
    - Map 인터페이스를 구현한 구현체
    - 보조 해시함수 사용X
    - 동기화를 지원하며 해시맵 보다 속도가 떨어짐
    
해시 맵 : 
    - 해시 함수를 통해 키를 해시 값으로 매핑하고 해시 값을 인덱스 또는 주소로 활용하여 key, value를 함께 저장하는 자료구조 해시 테이블과 동일
    - java 2에서 등장
    - 보조 해시함수 사용
    - 동기화를 지원하지 않으며 해시 테이블보다 속도가 빠름
    - 해시 버킷 데이터가 일정 개수 이상일 경우 구조를 연결리스트에서 트리(red-black-tree)로  
