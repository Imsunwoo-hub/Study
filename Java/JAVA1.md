# JAVA
  - JVM만 있다면 어떠한 운영체제에서도 독립적으로 실행될 수 있음
    - JVM(자바 가상 머신)
      - 시스템 메모리를 관리하면서 자바기반 어플리케이션을 위해 이식가능한 환경 제공 
      - 목적 : 자바프로그램이 어느기기나 운영체제상에서도 실행될 수 있도록 하는것
               프로그램 메모리를 관리하고 최적화 하는것 
      - 구성
        - 자바 컴파일러 : 자바 소스코드를 바이트코드로 변환시켜줌(.java -> .class)
        - 클래스로더 : 클래스를 로드하고 메모리영역에 배치시킴(동적로드 담당)
                       1) 로드 : 클래스 파일을 가져와 JVM 메모리에 로드
                       2) 검증 : 코드가 명세에 맞게 구성되어 있는지 검사
                       3) 준비 : 클래스가 필요로하는 메모리를 할당
                       4) 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
                       5) 초기화 : 클래스 변수들을 적절한 값으로 초기화
        - 런타임 데이터 영역 : JVM이 운영체제 위에서 실행되면서 할당 받는 메모리 영역
          - PC레지스터 : 스레드가 어떤 명령어로 실행되어야 할지 기록하는 부분, JVM 명령의 주소를 가짐
          - 스택 영역 : 지역변수, 매개변수, 메서드 정보, 임시데이터 등을 저장하는 영역
          - 네이티브 메서드 영역 : 실제 실행할 수 있는 기계어로 작성된 프로그램이 저장되고 실행되는 영역
          - 힙 영역 : 런타임 시 동적으로 생성되는 객체 정보가 저장되는 영역, 가비지 컬렉터의 대상이됨
          - 메서드 영역 : JVM이 시작될 때 생성되고 상수 풀, 전역변수, 정적변수, 메서드 정보 등이 저장되는 영역 
        - 가비지 컬렉션(GC)
          - 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내어 제거하는 역할 
          - 참조되지 않는 객체들을 탐색 후 삭제 -> 삭제된 객체의 메모리 반환 -> 힙 메모리 재사용
          - stop the world : GC가 실행되기 위해서 JVM이 어플리케이션 실행을 잠시 멈추는것
          - GC 튜닝 : 대개 stop the world 시간을 줄이는 것을 말함
          - GB의 대상 : 객체가 null 인 경우, 블럭 실행 종료 후 블럭 내에서 생성된 객체, 부모 객체가 null인 자식 객체
          - 메모리 해체 과정 : 모든 객체를 스캔하며 참조되지 않는 객체를 찾아냄(마킹) -> 참조되지 않는 객체를 제거하고 메모리 반환(제거) -> 참조 되고 있는 객체를 묶어 메모리 공간 확보(컴팩팅)
          - Generational GC : weak Generational Hypothesis 를 기반으로 메모리를 관리하는기법
                              메모리를 young 영역과 old 영역으로 나누어 관리
                              새로 생성된 객체를 young 영역에 저장 -> young 영역을 탐색하며 참조되지 않는 객체 제거 참조되고 있는 객체는 별도의 영역으로 옮기고 세대 증가(minor GC) 
                              -> 지정한 세대 이상의 객체를 old 영역으로 옮김 -> old 영역을 탐색하며 참조되지 않는 객체를 삭제(major/full GC) 
          - Weak Generational Hypothesis : 신규 객체는 금방 사용하지 않는 상태가 되고 오래된 객체는 신규객체로의 참조가 매우 적게 존재한다는 가설
    - 자바 컴파일 과정
      1) 자바 코드작성
      2) 컴파일러가 소스파일을 바이트코드파일로 바꿈
      3) 컴파일 된 버아트코드를 JVM 클래스 로더에게 전달
      4) 클래스로더는 동적로딩을 통해 필요한 클래스를 로딩 및 링크하여 런타임 데이터영역에 올림
      5) 실행엔지는 JVM 메모리에 올라온 바이트코드를 명령어 단위로 실행
        * 실행엔진 : 1) 인터프리터 : 명령어를 하나씩 읽어와 실행
                     2) JIT 컴파일러 : 바이트코드 전체를 컴파일하여 바이너리 코드로 변경하고 직접실행
                     
   - 타입
      - 기본형 타입 : 논리형, 문자형, 정수형, 실수형
                      사용하기 전 반드시 선언되어야함 
                      OS에 따라 자료형 길이가 변하지 않음
                      스택 메모리에 저장됨
                      비 객체 타입, null 값을 가질 수 없음, Wrapper class를 통해 null 값을 넣을 수 있음
      - 참조형 타입 : 기본형을 제외한 모든 타입
                      자바 최상위 클래스인 Object 클래스를 상속하는 모든 클래스
                      new 를 통해 객체 생성
                      힙 영역에 생성되고 가비지 컬렉터가 메모리 해제(실제값은 힙 영역에 저장, 스택영역에 주소값 저장)
                      null 값을 가질 수 있음
  - call by value
      - 값에 의한 호출
      - 함수 호출 시 전달되는 변수 값을 복사해서 함수인자로 전달
      - 복사된 변수는 함수안에서 지역변수 속성을 가짐
      - 함수안에서 인자가 변경되더라도 외부 변수는 변경되지 않음
      - 기본형 타입이 인자로 전달됨(String은 참조형 타입이지만 기본형으로 적용)
  - call by reference
      - 참조에 의한 호출
      - 함수 호출 시 전달되는 변수의 참조값을 전달
      - 함수안에서 인자값이 변경되면 실제 객체값도 변경됨
      - 메모리 공간 할당 문제를 해결가능
  
  - 문자열 클래스
      - String : new 연산을 통해 생성된 인스턴스의 메모리 공간은 변하지 않음
                 GC의 대상이됨
                 문자열 연산시 새로 객체를 만드는 overhead 발생
                 조회 연산에 좋음
                 연산이 없는 멀티쓰레드 환경에 용이
      - StringBuild : new 연산을 통해 한번만 생성(메모리 공간이 변함)
                      동기화를 지원하지 않음
                      문자열 연산이 많은 싱글쓰레드 환경에 용이
      - StringBuffer : new 연산을 통해 한번만 생성(메모리 공간이 변함)
                       동가화를 지원함
                       문자열 연산이 많은 멀티쓰레드 환경에 용이
  - 캐스팅
      - 특정 값을 다른 타입으로 형변환 하는것
      - 묵시적 형변환 : 캐스팅이 자동으로 발생하는것 (작은 크기의 타입에서 큰 크기의 타입으로)
      - 명시적 형변환 : 캐스팅할 내용을 명시해 주는것 (큰 크기의 타입에서 작은 크기의 타입으로)
  - 오류 
      - 에러 : 메모리 부족, 스택오버플로우 등과 같이 시스템 수준에서 발생하며 발생하면 심각한 문제를 야기
      - 예외 : 개발자가 구현한 로직에서 발생하며 코드를 통해서 처리가 가능한 문제
          - checked Exception : 예외 처리가 필수이며 컴파일 단계에서 발견되는 예외
          - Unchecked Exception : 컴파일 단계에서 체크되지 않고 런타임시 발생하는 
  
